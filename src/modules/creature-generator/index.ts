namespace FFT {
    export class CreatureGeneratorModule {
        static async initialize(): Promise<void> {
            try {
                // Initialize the creature generator component
                await CreatureGeneratorComponent.initialize();
                
                // Set up hooks
                this.setupHooks();
                
                // Set up console API
                this.setupConsoleAPI();
                
                console.log("FFTweaks | Creature Generator Module initialized");
                
            } catch (error) {
                console.error("FFTweaks | Failed to initialize Creature Generator Module:", error);
            }
        }
        
        private static setupHooks(): void {
            // Hook into token creation for automatic enhancement
            Hooks.on("createToken", async (tokenDocument: TokenDocument) => {
                try {
                    if (!game.user?.isGM) return;
                    
                    const actor = tokenDocument.actor;
                    if (!actor || actor.type !== "npc") return;
                    
                    // Check if actor has the auto-generate flag or is unnamed/generic
                    const shouldAutoGenerate = (actor as any).getFlag("fftweaks", "autoGenerate") ||
                                             this.isGenericNPC(actor);
                    
                    if (shouldAutoGenerate) {
                        console.log(`FFTweaks | Auto-generating creature for: ${actor.name}`);
                        
                        // Determine template based on actor name or type
                        const templateName = this.determineTemplate(actor);
                        const creatureType = this.determineCreatureType(actor);
                        
                        await CreatureGeneratorComponent.enhanceExistingActor(
                            actor,
                            templateName,
                            { creatureType }
                        );
                        
                        // Auto-select the placed token so the HUD appears (with delay)
                        setTimeout(() => {
                            const placedToken = canvas.tokens?.get(tokenDocument.id);
                            if (placedToken) placedToken.control();
                        }, 200);
                    }
                    
                } catch (error) {
                    console.error("FFTweaks | Error in createToken hook:", error);
                }
            });

            // Hook into Argon HUD updates to reorganize weapon sets for auto-generated creatures
            Hooks.on("updateItem", async (item: any, updateData: any) => {
                const actor = item.actor;
                if (!actor || actor.type !== "npc") return;
                
                // Only reorganize for auto-generated creatures
                const isAutoGenerated = (actor as any).getFlag("fftweaks", "autoGenerate") || 
                                       this.isGenericNPC(actor);
                if (!isAutoGenerated) return;
                
                // Debounce to avoid multiple rapid updates
                const gameAny = game as any;
                gameAny._weaponSetDebounce ??= {};
                
                const actorId = actor.id;
                clearTimeout(gameAny._weaponSetDebounce[actorId]);
                
                gameAny._weaponSetDebounce[actorId] = setTimeout(() => {
                    this.reorganizeWeaponSets(actor);
                }, 100);
            });
        }

        private static async reorganizeWeaponSets(actor: any): Promise<void> {
            try {
                // Wait for HUD to be rendered
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const hudRoot = document.querySelector(".extended-combat-hud");
                if (!hudRoot) {
                    console.log("FFTweaks | No Argon HUD found, skipping weapon set reorganization");
                    return;
                }
                
                const weaponSets = hudRoot.querySelectorAll(".weapon-set");
                if (weaponSets.length === 0) {
                    console.log("FFTweaks | No weapon sets found in HUD");
                    return;
                }
                
                console.log(`FFTweaks | Reorganizing weapon sets for ${actor.name}`);
                
                // Get equipped weapons and shields from the actor
                const equippedItems = actor.items.filter((item: any) => item.system?.equipped);
                const weapons = equippedItems.filter((item: any) => {
                    const system = item.system;
                    const itemType = system?.type?.value;
                    // D&D 5e weapon types: simpleM, simpleR, martialM, martialR, etc.
                    const isWeapon = itemType === "weapon" || 
                                   itemType?.includes("M") || // Melee weapons (simpleM, martialM)
                                   itemType?.includes("R") || // Ranged weapons (simpleR, martialR)
                                   system?.actionType || 
                                   system?.damage?.parts?.length > 0;
                    return isWeapon;
                });
                const shields = equippedItems.filter((item: any) => 
                    item.system?.armor?.type === "shield" || 
                    item.name?.toLowerCase().includes("shield")
                );
                
                console.log(`FFTweaks | Found ${weapons.length} weapons:`, weapons.map(w => w.name));
                console.log(`FFTweaks | Found ${shields.length} shields:`, shields.map(s => s.name));
                
                // Organize weapons by type: melee first, then ranged
                const meleeWeapons = weapons.filter((w: any) => {
                    const itemType = w.system?.type?.value;
                    const range = w.system?.range?.value;
                    const actionType = w.system?.actionType;
                    // Check for melee weapon types (simpleM, martialM) or melee characteristics
                    const isMelee = itemType?.includes("M") || 
                                  (!range || range <= 5) || 
                                  actionType === "mwak";
                    console.log(`FFTweaks | Weapon ${w.name}: type=${itemType}, range=${range}, actionType=${actionType}, isMelee=${isMelee}`);
                    return isMelee;
                });
                
                const rangedWeapons = weapons.filter((w: any) => {
                    const itemType = w.system?.type?.value;
                    const range = w.system?.range?.value;
                    const actionType = w.system?.actionType;
                    // Check for ranged weapon types (simpleR, martialR) or ranged characteristics
                    const isRanged = itemType?.includes("R") || 
                                   (range && range > 5) || 
                                   actionType === "rwak";
                    return isRanged;
                });
                
                console.log(`FFTweaks | Melee weapons: ${meleeWeapons.length}`, meleeWeapons.map(w => w.name));
                console.log(`FFTweaks | Ranged weapons: ${rangedWeapons.length}`, rangedWeapons.map(w => w.name));
                
                let setIndex = 0;
                
                // Set 1: Melee weapon + shield
                if (meleeWeapons.length > 0 && setIndex < weaponSets.length) {
                    const weaponSet = weaponSets[setIndex] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    
                    // Clear first
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                    
                    // Put melee weapon in primary slot
                    if (primarySlot && meleeWeapons[0]?.img) {
                        const weaponImg = meleeWeapons[0].img;
                        primarySlot.style.backgroundImage = `url("${weaponImg}")`;
                        console.log(`FFTweaks | Set weapon set ${setIndex + 1} primary: ${meleeWeapons[0].name} (${weaponImg})`);
                    }
                    
                    // Put shield in secondary slot if available
                    if (secondarySlot && shields.length > 0 && shields[0]?.img) {
                        const shieldImg = shields[0].img;
                        secondarySlot.style.backgroundImage = `url("${shieldImg}")`;
                        console.log(`FFTweaks | Set weapon set ${setIndex + 1} secondary: ${shields[0].name} (${shieldImg})`);
                    }
                    
                    setIndex++;
                }
                
                // Set 2: Ranged weapon
                if (rangedWeapons.length > 0 && setIndex < weaponSets.length) {
                    const weaponSet = weaponSets[setIndex] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    
                    // Clear first
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                    
                    if (primarySlot && rangedWeapons[0]?.img) {
                        const weaponImg = rangedWeapons[0].img;
                        primarySlot.style.backgroundImage = `url("${weaponImg}")`;
                        console.log(`FFTweaks | Set weapon set ${setIndex + 1} primary: ${rangedWeapons[0].name} (${weaponImg})`);
                    }
                    
                    setIndex++;
                }
                
                // Clear remaining weapon sets
                for (let i = setIndex; i < weaponSets.length; i++) {
                    const weaponSet = weaponSets[i] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                }
                
                console.log(`FFTweaks | Weapon set reorganization complete for ${actor.name}`);
                
            } catch (error) {
                console.error("FFTweaks | Error reorganizing weapon sets:", error);
            }
        }

        
        private static setupConsoleAPI(): void {
            // Expose API to global FFT namespace
            if (!(window as any).FFT) {
                (window as any).FFT = {};
            }
            
            (window as any).FFT.CreatureGenerator = {
                // Main generation function
                generateCreature: async (actorName: string, templateName: string = "guard", options: any = {}) => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, options);
                },

                // Enhance existing actor
                enhanceActor: async (actor: Actor, templateName: string = "guard", options: any = {}) => {
                    return await CreatureGeneratorComponent.enhanceExistingActor(actor, templateName, options);
                },
                
                // Convenience functions for each creature type
                generateMinion: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "minion" });
                },
                
                generateStandard: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "standard" });
                },
                
                generateElite: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "elite" });
                },
                
                generateBoss: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "boss" });
                },
                
                // Utility functions
                getAvailableTemplates: () => {
                    return CreatureGeneratorComponent.getAvailableTemplates();
                },
                
                reloadTemplates: async () => {
                    return await CreatureGeneratorComponent.reloadTemplates();
                },
                
                calculateCR: (partyLevel: number, partySize: number, difficulty: string, creatureType: string) => {
                    return CRCalculator.calculateTargetCR(
                        partyLevel,
                        partySize,
                        difficulty as EncounterDifficulty,
                        creatureType as CreatureType
                    );
                }
            };
            
            console.log("FFTweaks | Creature Generator API exposed to console");
        }
        
        private static isGenericNPC(actor: Actor): boolean {
            // Check if this is a generic/unnamed NPC that should be auto-generated
            const genericNames = [
                "guard", "soldier", "bandit", "cultist", "acolyte",
                "commoner", "noble", "knight", "archer", "warrior",
                "new actor", "npc", "creature"
            ];
            
            const actorName = (actor as any).name?.toLowerCase() || "";
            return genericNames.some(name => actorName.includes(name));
        }
        
        private static determineTemplate(actor: Actor): string {
            const actorName = (actor as any).name?.toLowerCase() || "";
            
            // Simple template matching based on name
            if (actorName.includes("guard") || actorName.includes("soldier") || actorName.includes("warrior")) {
                return "guard";
            }
            
            // Default to guard template for now
            return "guard";
        }
        
        private static determineCreatureType(actor: Actor): CreatureType {
            const actorName = (actor as any).name?.toLowerCase() || "";
            
            // Determine creature type based on name keywords
            if (actorName.includes("minion") || actorName.includes("weak")) {
                return "minion";
            } else if (actorName.includes("elite") || actorName.includes("veteran")) {
                return "elite";
            } else if (actorName.includes("boss") || actorName.includes("captain") || actorName.includes("leader")) {
                return "boss";
            }
            
            return "standard";
        }
    }
}