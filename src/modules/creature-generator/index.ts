namespace FFT {
    export class CreatureGeneratorModule {
        static async initialize(): Promise<void> {
            try {
                // Initialize the creature generator component
                await CreatureGeneratorComponent.initialize();
                
                // Set up hooks
                this.setupHooks();
                
                // Set up console API
                this.setupConsoleAPI();
                
                console.log("FFTweaks | Creature Generator Module initialized");
                
            } catch (error) {
                console.error("FFTweaks | Failed to initialize Creature Generator Module:", error);
            }
        }
        
        private static setupHooks(): void {
            // Hook into token creation for automatic enhancement
            Hooks.on("createToken", async (tokenDocument: TokenDocument) => {
                try {
                    if (!game.user?.isGM) return;
                    
                    const actor = tokenDocument.actor;
                    if (!actor || actor.type !== "npc") return;
                    
                    // Check if actor has the auto-generate flag or is unnamed/generic
                    const shouldAutoGenerate = (actor as any).getFlag("fftweaks", "autoGenerate") ||
                                             this.isGenericNPC(actor);
                    
                    if (shouldAutoGenerate) {
                        console.log(`FFTweaks | Auto-generating creature for: ${actor.name}`);
                        
                        // Determine template based on actor name or type
                        const templateName = this.determineTemplate(actor);
                        const creatureType = this.determineCreatureType(actor);
                        
                        await CreatureGeneratorComponent.enhanceExistingActor(
                            actor,
                            templateName,
                            { creatureType }
                        );
                        
                        // Auto-select the placed token so the HUD appears (with delay)
                        setTimeout(() => {
                            const placedToken = canvas.tokens?.get(tokenDocument.id);
                            if (placedToken) placedToken.control();
                        }, 200);
                    }
                    
                } catch (error) {
                    console.error("FFTweaks | Error in createToken hook:", error);
                }
            });

            // Hook into Argon HUD updates to reorganize weapon sets for auto-generated creatures
            Hooks.on("updateItem", async (item: any, updateData: any) => {
                const actor = item.actor;
                if (!actor || actor.type !== "npc") return;
                
                // Only reorganize for auto-generated creatures
                const isAutoGenerated = (actor as any).getFlag("fftweaks", "autoGenerate") || 
                                       this.isGenericNPC(actor);
                if (!isAutoGenerated) return;
                
                // Debounce to avoid multiple rapid updates
                const gameAny = game as any;
                gameAny._weaponSetDebounce ??= {};
                
                const actorId = actor.id;
                clearTimeout(gameAny._weaponSetDebounce[actorId]);
                
                gameAny._weaponSetDebounce[actorId] = setTimeout(() => {
                    this.reorganizeWeaponSets(actor);
                }, 100);
            });

            // Hook into Argon HUD rendering to prevent auto-sorting and maintain our organization
            Hooks.on("renderApplication", (app: any, html: any) => {
                if (app.constructor.name === "EnhancedCombatHUD" || app.id === "enhancedcombathud") {
                    // Check if this is for an auto-generated creature
                    const token = canvas.tokens?.controlled[0];
                    if (!token?.actor) return;
                    
                    const actor = token.actor;
                    const isAutoGenerated = (actor as any).getFlag("fftweaks", "autoGenerate") || 
                                           this.isGenericNPC(actor);
                    
                    if (isAutoGenerated && actor.type === "npc") {
                        // Delay to let Argon finish its initial render, then reorganize
                        setTimeout(() => {
                            this.reorganizeWeaponSets(actor);
                        }, 150);
                    }
                }
            });

            // Hook into control token changes to maintain weapon set organization
            Hooks.on("controlToken", (token: any, controlled: boolean) => {
                if (!controlled || !token?.actor) return;
                
                const actor = token.actor;
                const isAutoGenerated = (actor as any).getFlag("fftweaks", "autoGenerate") || 
                                       this.isGenericNPC(actor);
                
                if (isAutoGenerated && actor.type === "npc") {
                    // Reorganize weapon sets when token is selected
                    setTimeout(() => {
                        this.reorganizeWeaponSets(actor);
                    }, 200);
                }
            });
        }

        private static async reorganizeWeaponSets(actor: any): Promise<void> {
            try {
                // Check if this actor uses the loadout system - if so, skip auto-reorganization
                const useLoadoutSystem = actor.getFlag("fftweaks", "useLoadoutSystem");
                if (useLoadoutSystem) {
                    console.log(`ðŸ”’ FFTweaks | Skipping auto-reorganization for ${actor.name} - uses LOADOUT system`);
                    return;
                }
                
                // Wait for HUD to be rendered
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const hudRoot = document.querySelector(".extended-combat-hud");
                if (!hudRoot) {
                    console.log("FFTweaks | No Argon HUD found, skipping weapon set reorganization");
                    return;
                }
                
                const weaponSets = hudRoot.querySelectorAll(".weapon-set");
                if (weaponSets.length === 0) {
                    console.log("FFTweaks | No weapon sets found in HUD");
                    return;
                }
                
                console.log(`FFTweaks | Reorganizing weapon sets for ${actor.name}`);
                
                // Get equipped weapons and shields from the actor
                const equippedItems = actor.items.filter((item: any) => item.system?.equipped);
                const weapons = equippedItems.filter((item: any) => {
                    const system = item.system;
                    const itemType = system?.type?.value;
                    // D&D 5e weapon types: simpleM, simpleR, martialM, martialR, etc.
                    const isWeapon = itemType === "weapon" || 
                                   itemType?.includes("M") || // Melee weapons (simpleM, martialM)
                                   itemType?.includes("R") || // Ranged weapons (simpleR, martialR)
                                   system?.actionType || 
                                   system?.damage?.parts?.length > 0;
                    return isWeapon;
                });
                const shields = equippedItems.filter((item: any) => 
                    item.system?.armor?.type === "shield" || 
                    item.name?.toLowerCase().includes("shield")
                );
                
                console.log(`FFTweaks | Found ${weapons.length} weapons:`, weapons.map(w => w.name));
                console.log(`FFTweaks | Found ${shields.length} shields:`, shields.map(s => s.name));
                
                // Organize weapons by type: melee first, then ranged
                const meleeWeapons = weapons.filter((w: any) => {
                    const itemType = w.system?.type?.value;
                    const range = w.system?.range?.value;
                    const actionType = w.system?.actionType;
                    // Check for melee weapon types (simpleM, martialM) or melee characteristics
                    const isMelee = itemType?.includes("M") || 
                                  (!range || range <= 5) || 
                                  actionType === "mwak";
                    console.log(`FFTweaks | Weapon ${w.name}: type=${itemType}, range=${range}, actionType=${actionType}, isMelee=${isMelee}`);
                    return isMelee;
                });
                
                const rangedWeapons = weapons.filter((w: any) => {
                    const itemType = w.system?.type?.value;
                    const range = w.system?.range?.value;
                    const actionType = w.system?.actionType;
                    // Check for ranged weapon types (simpleR, martialR) or ranged characteristics
                    const isRanged = itemType?.includes("R") || 
                                   (range && range > 5) || 
                                   actionType === "rwak";
                    return isRanged;
                });
                
                console.log(`FFTweaks | Melee weapons: ${meleeWeapons.length}`, meleeWeapons.map(w => w.name));
                console.log(`FFTweaks | Ranged weapons: ${rangedWeapons.length}`, rangedWeapons.map(w => w.name));
                
                // Set 1: Primary melee weapon + shield
                if (meleeWeapons.length > 0 && weaponSets.length > 0) {
                    const weaponSet = weaponSets[0] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    
                    // Clear first
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                    
                    // Put primary melee weapon in primary slot
                    if (primarySlot && meleeWeapons[0]?.img) {
                        const weaponImg = meleeWeapons[0].img;
                        primarySlot.style.backgroundImage = `url("${weaponImg}")`;
                        console.log(`FFTweaks | Set 1 primary: ${meleeWeapons[0].name} (${weaponImg})`);
                    }
                    
                    // Put shield in secondary slot if available
                    if (secondarySlot && shields.length > 0 && shields[0]?.img) {
                        const shieldImg = shields[0].img;
                        secondarySlot.style.backgroundImage = `url("${shieldImg}")`;
                        console.log(`FFTweaks | Set 1 secondary: ${shields[0].name} (${shieldImg})`);
                    }
                }
                
                // Set 2: Primary ranged weapon + ammunition
                if (rangedWeapons.length > 0 && weaponSets.length > 1) {
                    const weaponSet = weaponSets[1] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    
                    // Clear first
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                    
                    if (primarySlot && rangedWeapons[0]?.img) {
                        const weaponImg = rangedWeapons[0].img;
                        primarySlot.style.backgroundImage = `url("${weaponImg}")`;
                        console.log(`FFTweaks | Set 2 primary: ${rangedWeapons[0].name} (${weaponImg})`);
                    }
                    
                    // Try to find ammunition for the secondary slot
                    const ammunition = equippedItems.find((item: any) => 
                        item.system?.type?.value === "ammo" || 
                        item.name?.toLowerCase().includes("bolt") ||
                        item.name?.toLowerCase().includes("arrow")
                    );
                    
                    if (secondarySlot && ammunition?.img) {
                        const ammoImg = ammunition.img;
                        secondarySlot.style.backgroundImage = `url("${ammoImg}")`;
                        console.log(`FFTweaks | Set 2 secondary: ${ammunition.name} (${ammoImg})`);
                    }
                }
                
                // Set 3: Alternative weapons or thrown weapons
                if (weaponSets.length > 2) {
                    const weaponSet = weaponSets[2] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    
                    // Clear first
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                    
                    // Find additional weapons to populate set 3
                    let set3Primary = null;
                    let set3Secondary = null;
                    
                    // Priority 1: Additional melee weapons
                    if (meleeWeapons.length > 1) {
                        set3Primary = meleeWeapons[1];
                    }
                    // Priority 2: Additional ranged weapons  
                    else if (rangedWeapons.length > 1) {
                        set3Primary = rangedWeapons[1];
                    }
                    // Priority 3: Thrown weapons (javelins, handaxes, daggers)
                    else {
                        const thrownWeapons = weapons.filter((w: any) => {
                            const name = w.name?.toLowerCase();
                            const properties = w.system?.properties || {};
                            return name?.includes("javelin") || 
                                   name?.includes("handaxe") || 
                                   name?.includes("dagger") ||
                                   properties.thr; // D&D 5e thrown property
                        });
                        if (thrownWeapons.length > 0) {
                            set3Primary = thrownWeapons[0];
                        }
                    }
                    
                    // For set 3 secondary, try to find a complementary item
                    if (set3Primary) {
                        // If primary is melee, try to add another shield or off-hand weapon
                        const primaryType = set3Primary.system?.type?.value;
                        if (primaryType?.includes("M")) {
                            // Try additional shield or light weapon
                            if (shields.length > 1) {
                                set3Secondary = shields[1];
                            } else {
                                const lightWeapons = meleeWeapons.filter((w: any) => 
                                    w !== set3Primary && 
                                    (w.name?.toLowerCase().includes("dagger") || 
                                     w.system?.properties?.lgt)
                                );
                                if (lightWeapons.length > 0) {
                                    set3Secondary = lightWeapons[0];
                                }
                            }
                        }
                    }
                    
                    // Set the images
                    if (primarySlot && set3Primary?.img) {
                        const weaponImg = set3Primary.img;
                        primarySlot.style.backgroundImage = `url("${weaponImg}")`;
                        console.log(`FFTweaks | Set 3 primary: ${set3Primary.name} (${weaponImg})`);
                    }
                    
                    if (secondarySlot && set3Secondary?.img) {
                        const secondaryImg = set3Secondary.img;
                        secondarySlot.style.backgroundImage = `url("${secondaryImg}")`;
                        console.log(`FFTweaks | Set 3 secondary: ${set3Secondary.name} (${secondaryImg})`);
                    }
                }
                
                // Clear any remaining weapon sets (if there are more than 3)
                for (let i = 3; i < weaponSets.length; i++) {
                    const weaponSet = weaponSets[i] as HTMLElement;
                    const primarySlot = weaponSet.querySelector(".set-primary") as HTMLElement;
                    const secondarySlot = weaponSet.querySelector(".set-secondary") as HTMLElement;
                    if (primarySlot) primarySlot.style.backgroundImage = "";
                    if (secondarySlot) secondarySlot.style.backgroundImage = "";
                }
                
                console.log(`FFTweaks | Weapon set reorganization complete for ${actor.name}`);
                
            } catch (error) {
                console.error("FFTweaks | Error reorganizing weapon sets:", error);
            }
        }

        
        private static setupConsoleAPI(): void {
            // Expose API to global FFT namespace
            if (!(window as any).FFT) {
                (window as any).FFT = {};
            }
            
            (window as any).FFT.CreatureGenerator = {
                // Main generation function
                generateCreature: async (actorName: string, templateName: string = "guard", options: any = {}) => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, options);
                },

                // Enhance existing actor
                enhanceActor: async (actor: Actor, templateName: string = "guard", options: any = {}) => {
                    return await CreatureGeneratorComponent.enhanceExistingActor(actor, templateName, options);
                },
                
                // Convenience functions for each creature type
                generateMinion: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "minion" });
                },
                
                generateStandard: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "standard" });
                },
                
                generateElite: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "elite" });
                },
                
                generateBoss: async (actorName: string, templateName: string = "guard") => {
                    return await CreatureGeneratorComponent.generateCreature(actorName, templateName, { creatureType: "boss" });
                },
                
                // Utility functions
                getAvailableTemplates: () => {
                    return CreatureGeneratorComponent.getAvailableTemplates();
                },
                
                reloadTemplates: async () => {
                    return await CreatureGeneratorComponent.reloadTemplates();
                },
                
                calculateCR: (partyLevel: number, partySize: number, difficulty: string, creatureType: string) => {
                    return CRCalculator.calculateTargetCR(
                        partyLevel,
                        partySize,
                        difficulty as EncounterDifficulty,
                        creatureType as CreatureType
                    );
                }
            };
            
            console.log("FFTweaks | Creature Generator API exposed to console");
        }
        
        private static isGenericNPC(actor: Actor): boolean {
            // Check if this is a generic/unnamed NPC that should be auto-generated
            const genericNames = [
                "guard", "soldier", "bandit", "cultist", "acolyte",
                "commoner", "noble", "knight", "archer", "warrior",
                "new actor", "npc", "creature"
            ];
            
            const actorName = (actor as any).name?.toLowerCase() || "";
            return genericNames.some(name => actorName.includes(name));
        }
        
        private static determineTemplate(actor: Actor): string {
            const actorName = (actor as any).name?.toLowerCase() || "";
            
            // Simple template matching based on name
            if (actorName.includes("guard") || actorName.includes("soldier") || actorName.includes("warrior")) {
                return "guard";
            }
            
            // Default to guard template for now
            return "guard";
        }
        
        private static determineCreatureType(actor: Actor): CreatureType {
            const actorName = (actor as any).name?.toLowerCase() || "";
            
            // Determine creature type based on name keywords
            if (actorName.includes("minion") || actorName.includes("weak")) {
                return "minion";
            } else if (actorName.includes("elite") || actorName.includes("veteran")) {
                return "elite";
            } else if (actorName.includes("boss") || actorName.includes("captain") || actorName.includes("leader")) {
                return "boss";
            }
            
            return "standard";
        }
    }
}