/**
 * ============================================================================
 * UPDATE ADVANCEMENTS UTILITY
 * ============================================================================
 * 
 * This utility repairs/updates advancement items in a compendium item by using
 * saved item names from advancements.json. It's designed to fix broken UUID links
 * that occur when items are moved or recreated in different compendiums.
 * 
 * HOW IT WORKS:
 * 1. Reads saved advancement data from advancements.json (generated by AdvancementSync)
 * 2. Looks up the saved ITEM NAMES (not UUIDs, which may be broken)
 * 3. Searches the SOURCE compendium for items matching those names
 * 4. Rebuilds the advancement with fresh UUIDs from the source compendium
 * 
 * PREREQUISITES:
 * - Run FFT.Functions.syncAdvancements() first to generate advancements.json
 * - The advancements.json must contain valid item names (not [BROKEN] placeholders)
 * 
 * USAGE EXAMPLES:
 * 
 * // Update all advancements in a class, pulling items from fftweaks.spells
 * FFT.Functions.updateAdvancements(
 *     "Compendium.fftweaks.classes.Item.BB4w1RNuF0r4fQ68",
 *     "fftweaks.spells"
 * );
 * 
 * // Update a specific advancement only
 * FFT.Functions.updateAdvancements(
 *     "Compendium.fftweaks.classes.Item.BB4w1RNuF0r4fQ68.Advancement.XfjcpKcLiSJmzQau",
 *     "fftweaks.feats"
 * );
 * 
 * PARAMETERS:
 * @param targetUuid - UUID of the item or specific advancement to update
 *   - Item UUID format: "Compendium.{pack}.Item.{id}"
 *   - Advancement UUID format: "Compendium.{pack}.Item.{id}.Advancement.{advId}"
 * 
 * @param sourceCompendiumId - The compendium to pull fresh UUIDs from (e.g., "fftweaks.spells")
 *   - Items are matched by NAME (case-insensitive)
 *   - If no match is found, a warning is logged
 * 
 * ============================================================================
 */

import { Debug } from "../../utils/debug";
import advancementData from "../../plugins/advancement-sync/data/advancements.json";

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * Represents advancement data for a single item (class, background, species, feat, etc.)
 * This structure mirrors what's stored in advancements.json
 */
interface AdvancementItemData {
    /** The Foundry document ID of this item */
    id: string;
    /** List of ItemGrant/ItemChoice advancements in this item */
    advancements: {
        /** Foundry advancement ID */
        id: string;
        /** Display title of the advancement */
        title: string;
        /** "ItemGrant" or "ItemChoice" */
        type: string;
        /** Items contained in this advancement */
        items: {
            name: string;      // Item name (used for matching)
            type: string;      // Item type (feat, spell, etc.)
            uuid: string;      // Original UUID (may be broken)
            broken: boolean;   // True if UUID couldn't be resolved
        }[];
    }[];
    /** Nested subclasses (for class items only) */
    subclasses?: Record<string, AdvancementItemData>;
    /** Nested subspecies (for species items only) */
    subspecies?: Record<string, AdvancementItemData>;
}

/**
 * The hierarchical structure of advancements.json
 * Generated by AdvancementSync plugin
 */
interface HierarchicalSyncData {
    classes: {
        /** Shared features used by multiple classes (e.g., Fighting Style) */
        _Shared: Record<string, AdvancementItemData>;
        /** Class entries, keyed by class name */
        [className: string]: Record<string, AdvancementItemData> | AdvancementItemData;
    };
    /** Background entries, keyed by background name */
    backgrounds: Record<string, AdvancementItemData>;
    /** Species entries (with nested subspecies), keyed by species name */
    species: Record<string, AdvancementItemData>;
    /** Feats grouped by category */
    feats: {
        "Origin Feats": Record<string, AdvancementItemData>;
        "General Feats": Record<string, AdvancementItemData>;
        "Other": Record<string, AdvancementItemData>;
    };
}

// ============================================================================
// MAIN FUNCTION
// ============================================================================

/**
 * Updates advancement items using saved names from advancements.json.
 * Rebuilds advancement content with fresh UUIDs from the source compendium.
 * 
 * @param targetUuid - UUID of the target Item OR specific Advancement
 * @param sourceCompendiumId - Pack ID to pull fresh UUIDs from (e.g., "fftweaks.spells")
 */
const DEFAULT_SOURCE_COMPENDIUMS = [
    "fftweaks.classes",
    "fftweaks.backgrounds",
    "fftweaks.species",
    "fftweaks.feats",
    "fftweaks.spells",
    "fftweaks.items"
];

/**
 * Updates advancement items using saved names from advancements.json.
 * Rebuilds advancement content with fresh UUIDs from the source compendiums.
 * 
 * @param targetUuid - UUID of the target Item OR specific Advancement
 * @param sourceCompendiumIds - List of pack IDs to pull fresh UUIDs from (e.g., ["fftweaks.spells", "fftweaks.feats"])
 *                              Defaults to a standard list of fftweaks compendiums if not provided.
 */
export async function updateAdvancements(
    targetUuid: string,
    sourceCompendiumIds: string[] | string = DEFAULT_SOURCE_COMPENDIUMS
): Promise<void> {
    // Normalize sourceCompendiumIds to array
    const sources = Array.isArray(sourceCompendiumIds) ? sourceCompendiumIds : [sourceCompendiumIds];

    // -------------------------------------------------------------------------
    // STEP 1: Parse and validate the target UUID
    // -------------------------------------------------------------------------
    const uuidParts = targetUuid.split(".");

    if (uuidParts[0] !== "Compendium" || uuidParts.length < 4) {
        ui.notifications?.error("Invalid target UUID format.");
        return;
    }

    // Determine if targeting a specific advancement or the whole item
    const isSpecificAdvancement = uuidParts.includes("Advancement");
    const advancementId = isSpecificAdvancement
        ? uuidParts[uuidParts.indexOf("Advancement") + 1]
        : null;

    // Extract the item ID (5th part of UUID: Compendium.pack.type.Item.ID)
    const itemId = uuidParts[4];

    // Get the base item UUID (strip off .Advancement.xxx if present)
    const itemUuid = isSpecificAdvancement
        ? uuidParts.slice(0, uuidParts.indexOf("Advancement")).join(".")
        : targetUuid;

    // -------------------------------------------------------------------------
    // STEP 2: Load the target item from Foundry
    // -------------------------------------------------------------------------
    const targetItem = await fromUuid(itemUuid) as any;
    if (!targetItem) {
        ui.notifications?.error(`Target item not found: ${itemUuid}`);
        return;
    }

    // -------------------------------------------------------------------------
    // STEP 3: Find saved advancement data in advancements.json
    // -------------------------------------------------------------------------
    const savedData = findSavedData(advancementData as unknown as HierarchicalSyncData, itemId);
    if (!savedData) {
        ui.notifications?.error(`No saved advancement data found for item ${itemId}. Run syncAdvancements first.`);
        return;
    }

    // -------------------------------------------------------------------------
    // STEP 4: Build a name -> UUID lookup map from all source compendiums
    // -------------------------------------------------------------------------
    // Map item names (lowercase) to their UUIDs for quick lookup
    const sourceMap = new Map<string, string>();
    let packsFound = 0;

    for (const packId of sources) {
        const sourcePack = game.packs.get(packId);
        if (!sourcePack) {
            Debug.Warn(`Source compendium not found: ${packId}`);
            continue;
        }
        packsFound++;

        for (const indexEntry of sourcePack.index) {
            const entry = indexEntry as any;
            if (entry.name) {
                // If duplicates exist across packs, later packs overwrite earlier ones
                sourceMap.set(entry.name.toLowerCase(), `Compendium.${packId}.Item.${entry._id}`);
            }
        }
    }

    if (packsFound === 0) {
        ui.notifications?.error("No valid source compendiums found.");
        return;
    }

    Debug.Log(`Source map built with ${sourceMap.size} unique names from ${packsFound} compendiums`);

    // -------------------------------------------------------------------------
    // STEP 5: Get the item's current advancement data
    // -------------------------------------------------------------------------
    const itemData = targetItem.toObject();
    const advancements = itemData.system.advancement || [];

    if (advancements.length === 0) {
        ui.notifications?.warn(`No advancements in item: ${targetItem.name}`);
        return;
    }

    // Filter to only process advancements that exist in our saved data
    const savedAdvIds = savedData.advancements.map(a => a.id);
    const toProcess = isSpecificAdvancement
        ? advancements.filter((a: any) => a._id === advancementId)
        : advancements.filter((a: any) => savedAdvIds.includes(a._id));

    if (toProcess.length === 0) {
        ui.notifications?.warn("No matching advancements found to update.");
        return;
    }

    // -------------------------------------------------------------------------
    // STEP 6: Rebuild each advancement with fresh UUIDs
    // -------------------------------------------------------------------------
    let totalUpdateCount = 0;

    for (const adv of toProcess) {
        // Find the saved data for this advancement
        const savedAdv = savedData.advancements.find(s => s.id === adv._id);
        if (!savedAdv || savedAdv.items.length === 0) continue;

        Debug.Log(`Processing: ${adv.title || adv.type}`);

        // ItemChoice uses "pool", ItemGrant uses "items"
        const isChoice = adv.type === "ItemChoice";
        const existingEntries = (isChoice ? adv.configuration?.pool : adv.configuration?.items) || [];
        const newEntries: any[] = [];
        let updatedInAdvancement = 0;
        let preservedInAdvancement = 0;

        // For each saved item name, find it in the source compendium
        for (const savedItem of savedAdv.items) {
            const name = savedItem.name.toLowerCase();

            // Skip items that were already broken when synced
            if (name === "[broken]" || name === "[missing uuid]") {
                continue;
            }

            // Look up the item by name in our source map
            if (sourceMap.has(name)) {
                const newUuid = sourceMap.get(name)!;
                // ItemChoice entries only need uuid; ItemGrant needs uuid + optional flag
                newEntries.push(isChoice ? { uuid: newUuid } : { uuid: newUuid, optional: false });

                // Only count as updated if the UUID actually changed
                if (newUuid !== savedItem.uuid) {
                    totalUpdateCount++;
                    updatedInAdvancement++;
                } else {
                    // UUID is same, so it's technically "preserved" but because we found it in source
                    preservedInAdvancement++;
                }
            } else {
                // Item not found in any source compendium
                // Attempt to preserve the existing entry if UUID matches
                const existingEntry = existingEntries.find((e: any) => e.uuid === savedItem.uuid);

                if (existingEntry) {
                    newEntries.push(existingEntry);
                    preservedInAdvancement++;
                    Debug.Log(`  [NO MATCH] "${savedItem.name}" not in sources. Keeping existing.`);
                } else {
                    // Fallback: keep the original saved UUID even if not currently in item
                    newEntries.push(isChoice ? { uuid: savedItem.uuid } : { uuid: savedItem.uuid, optional: false });
                    Debug.Warn(`Restored missing item: ${savedItem.name}`);
                }
            }
        }

        if (preservedInAdvancement > 0) {
            Debug.Log(`  - Updated ${updatedInAdvancement}, Preserved ${preservedInAdvancement}`);
        }

        // Replace the advancement's items/pool with our new entries
        if (!adv.configuration) adv.configuration = {};
        if (isChoice) {
            adv.configuration.pool = newEntries;
        } else {
            adv.configuration.items = newEntries;
        }
    }

    // -------------------------------------------------------------------------
    // STEP 7: Save the updated item back to Foundry
    // -------------------------------------------------------------------------
    if (totalUpdateCount === 0) {
        ui.notifications?.info(`Checked ${targetItem.name}: All items up to date.`);
        return;
    }

    try {
        await targetItem.update({ "system.advancement": advancements });
        const msg = `Updated ${totalUpdateCount} items in ${targetItem.name}`;
        ui.notifications?.info(msg);
        Debug.Success(msg);
    } catch (error) {
        Debug.Error("Failed to update advancements:", error);
        ui.notifications?.error("Failed to update advancements. Check console.");
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Searches the hierarchical advancements.json structure for an item by its ID.
 * Checks all categories: classes (including _Shared and subclasses), 
 * backgrounds, species (including subspecies), and all feat categories.
 * 
 * @param data - The parsed advancements.json data
 * @param itemId - The Foundry document ID to find
 * @returns The saved advancement data, or null if not found
 */
function findSavedData(data: HierarchicalSyncData, itemId: string): AdvancementItemData | null {
    // Search shared class features first (e.g., Fighting Style)
    for (const [, sharedData] of Object.entries(data.classes._Shared || {})) {
        if (sharedData.id === itemId) return sharedData;
    }

    // Search classes and their nested subclasses
    for (const [key, value] of Object.entries(data.classes)) {
        if (key === "_Shared") continue;
        const classData = value as AdvancementItemData;
        if (classData.id === itemId) return classData;
        if (classData.subclasses) {
            for (const [, subclassData] of Object.entries(classData.subclasses)) {
                if (subclassData.id === itemId) return subclassData;
            }
        }
    }

    // Search backgrounds
    for (const [, bgData] of Object.entries(data.backgrounds)) {
        if (bgData.id === itemId) return bgData;
    }

    // Search species and their nested subspecies
    for (const [, speciesData] of Object.entries(data.species)) {
        if (speciesData.id === itemId) return speciesData;
        if (speciesData.subspecies) {
            for (const [, subData] of Object.entries(speciesData.subspecies)) {
                if (subData.id === itemId) return subData;
            }
        }
    }

    // Search all feat categories
    for (const category of Object.values(data.feats)) {
        for (const [, featData] of Object.entries(category)) {
            if (featData.id === itemId) return featData;
        }
    }

    return null;
}
